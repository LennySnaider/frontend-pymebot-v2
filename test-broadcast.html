<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test BroadcastChannel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
        }
        .container {
            border: 2px solid #ddd;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        h1 {
            color: #333;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .log {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        .timestamp {
            color: #666;
            font-size: 0.9em;
        }
        .message {
            color: #0066cc;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Test de BroadcastChannel para Lead Updates</h1>
    
    <div class="container">
        <h2>Pestaña Emisora (Chat)</h2>
        <button onclick="sendUpdate()">Enviar Actualización de Lead</button>
        <div id="sender-log" class="log"></div>
    </div>
    
    <div class="container">
        <h2>Pestaña Receptora (Sales Funnel)</h2>
        <button onclick="clearLog()">Limpiar Log</button>
        <div id="receiver-log" class="log"></div>
    </div>

    <script>
        // Crear canales (simulando dos pestañas)
        const channel1 = new BroadcastChannel('lead-updates-channel');
        const channel2 = new BroadcastChannel('lead-updates-channel');
        
        let updateCount = 0;
        
        // Función para enviar actualización (simula el chat)
        function sendUpdate() {
            updateCount++;
            const message = {
                type: 'lead-stage-update',
                leadId: `lead-${Math.random().toString(36).substr(2, 9)}`,
                newStage: ['prospectando', 'calificacion', 'oportunidad'][Math.floor(Math.random() * 3)],
                timestamp: Date.now()
            };
            
            // Enviar por BroadcastChannel
            channel1.postMessage(message);
            
            const logEntry = `
                <div>
                    <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    <span class="message">Enviado: Lead ${message.leadId} → ${message.newStage}</span>
                </div>
            `;
            document.getElementById('sender-log').innerHTML += logEntry;
            
            // También guardar en localStorage como fallback
            const updates = JSON.parse(localStorage.getItem('lead-stage-updates-v2') || '[]');
            updates.push(message);
            if (updates.length > 10) updates.shift();
            localStorage.setItem('lead-stage-updates-v2', JSON.stringify(updates));
        }
        
        // Escuchar actualizaciones (simula el sales funnel)
        channel2.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'lead-stage-update') {
                const message = event.data;
                const delay = Date.now() - message.timestamp;
                
                const logEntry = `
                    <div>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        <span class="message">Recibido: Lead ${message.leadId} → ${message.newStage}</span>
                        <span class="timestamp">(demora: ${delay}ms)</span>
                    </div>
                `;
                document.getElementById('receiver-log').innerHTML += logEntry;
            }
        });
        
        // También escuchar storage events como fallback
        window.addEventListener('storage', (event) => {
            if (event.key === 'lead-stage-updates-v2' && event.newValue) {
                try {
                    const updates = JSON.parse(event.newValue);
                    const latestUpdate = updates[updates.length - 1];
                    if (latestUpdate && (Date.now() - latestUpdate.timestamp) < 5000) {
                        const delay = Date.now() - latestUpdate.timestamp;
                        
                        const logEntry = `
                            <div>
                                <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                                <span class="message">[Storage] Lead ${latestUpdate.leadId} → ${latestUpdate.newStage}</span>
                                <span class="timestamp">(demora: ${delay}ms)</span>
                            </div>
                        `;
                        document.getElementById('receiver-log').innerHTML += logEntry;
                    }
                } catch (error) {
                    console.error('Error parsing storage update:', error);
                }
            }
        });
        
        function clearLog() {
            document.getElementById('receiver-log').innerHTML = '';
        }
        
        // Limpiar canales al cerrar
        window.addEventListener('beforeunload', () => {
            channel1.close();
            channel2.close();
        });
    </script>
    
    <div style="margin-top: 40px; padding: 20px; background-color: #f0f0f0; border-radius: 8px;">
        <h3>Instrucciones:</h3>
        <ol>
            <li>Abre este archivo en dos pestañas diferentes del navegador</li>
            <li>En una pestaña, haz clic en "Enviar Actualización de Lead"</li>
            <li>Observa cómo la otra pestaña recibe la actualización instantáneamente</li>
            <li>La demora debe ser menor a 10ms usando BroadcastChannel</li>
            <li>Si BroadcastChannel no está disponible, se usará localStorage (demora ~100-500ms)</li>
        </ol>
    </div>
</body>
</html>